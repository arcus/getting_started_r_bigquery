---
title: "Getting Started: R and BigQuery"
format: 
  revealjs:
    theme: [serif, custom.scss]
    scrollable: true
    footer: Joy Payton, Children's Hospital of Philadelphia
    css: styles.css
editor: visual
---

------------------------------------------------------------------------

This slide deck was built in Quarto!

-   Use keyboard arrow keys to
    -   advance ( → ) and
    -   go back ( ← )
-   Type "s" to see speaker notes
-   Type "?" to see other keyboard shortcuts

```{r echo = FALSE}
library(countdown)
```



# Itinerary for Second Hour

-   Exploring Data
-   SQL Refresher (or SQL 101)
-   Querying in BigQuery



::: notes


:::


# Viewing "Starred" Data {.smaller}

::: {.columns .v-center-container}
::: {.column width="50%"}
Since there are so many public datasets, Google no longer displays those by default in BigQuery, even though you have access to them. That's why we "starred" them.

Now we can select to show "only starred data".
:::

::: {.column width="50%"}
![](media/bigquery_starred_data.png){.bordered}
:::
:::

::: notes
You might have several tabs open at this point, and I personally like to at least pretend that I keep my browser tabs to a minimum, although honestly, I often have 30 tabs open at a time. I'd like you to close all your GCP tabs except for one, and go back into your project and into BigQuery. That will be good practice for you in navigating in a project. So I'll switch now to sharing my screen. I'm going to close these extra tabs, then make sure my project is appropriately selected in the project selector. I can use the menu to go to BigQuery. Now, I'll choose to show only starred data, and it'll be much easier to see just the data I want for my project.
:::

# Structures of Data {.smaller}

::: {.columns .v-center-container}
::: {.column width="50%"}
-   Projects contain datasets
-   Datasets contain tables (point-in-time, established data) and views (live filters that show current data)
:::

::: {.column width="50%"}
![](media/bigquery_expanded_data.png){.bordered}
:::
:::

::: notes
In BigQuery, you can expand a project to show its included datasets, and expand datasets to show their included tables and views. Please expand into your projects and datasets using the triangle keys until you see something similar to the image on your screen. In this case, we have three tables in the ADI data, and seven tables in the CDC data. In the next few minutes, you'll look around at this data.
:::

# Exploring Data {.smaller}

You can click on a table's name to open it to the right. Take a look at the first three tabs available, which will be available for every table.

-   Schema (what the columns are)
-   Details (how big it is, other metadata)
-   Preview (very important because FREE)

![](media/table_info.png){.bordered} 

::: notes 

I'd like to invite you to look at one of these tables by clicking on the table name. Not every bit of metadata that shows up as an available tab will actually be populated with information, that really depends on the source of the data and what is included with it. For now, I want you to look at the first few tabs: Schema, which shows the columns in the table, Details, which has some other metadata, and Preview, which allows you to look over the data as if you were to issue a 'SELECT \*' SQL query on that table.

So I'll screen share at this point and walk you through this. I'm going to click on the first table in the broadstreet_adi dataset, and I can adjust the panes here using the sliding adjuster to make sure I can see the full table names. So I want to look at this first table, index by census block group. I click on it, and information opens up on the right. I'll look at Schema to get an idea of what my data contains. It looks like it has a lot of place identifiers, like fips codes, which in the United States are codes that can describe lots of things, but in this case are unique IDs for different geographies, like county, or state or census block group. There's also the area deprivation index percent, which might be some kind of measure that as I think might have something to do with the socioeconomic characteristics of that geographic area.

Looking at the schema can give me a good overview of the data, IF my columns are well named. In this case, they are. Not every data set has a full schema. For example, this dataset doesn't have anything in way of description for the fields, which is annoying.

Now we can briefly look at details. I don't care that much about this, but sometimes this pane might have interesting information about the sheer amount of data or some tagging that might be useful. Not for this data, however!

Let's then go on to preview. A great thing about previews in BigQuery is that they are FREE. In BigQuery, you pay not for the storage of the data but for the processing power of the queries you run. But previews are free and allow you to look at the data overall. This can be very useful in understanding more intuitively what's in the dataset. Are county names capitalized? Are numbers in decimal format, or integers? Are there units or abbreviations in the data? Preview is where you can get that information.

In Preview, you can page through the columns, see the overall number of rows, go to the last page, and so on. OK, I'm going to return to my slides now.

:::

# Data Exploration Exercise {.smaller}

::: {.columns .v-center-container}
::: {.column width="80%"}
Look through the tables in the Broadstreet ADI data and the CDC Births data to understand what the data is capturing, and identify the following:

-   One or more fields that has linking information in common, in that the data appears in both datasets (might not have the same field name) -- we'll call this our "join" data
-   One or more columns / fields in the ADI data that help characterize socioeconomic disadvantage and are in the same table as our join data
-   One or more columns / fields in the CDC data that help describe something about birth statistics and are in the same table as our join data
:::
:::

```{r echo = FALSE}
library(countdown)
countdown(minutes = 5, seconds = 00)
```

::: notes
Please look through the tables in the Broadstreet ADI data and the CDC Births data, using the Schema and Preview tabs that we just explored to try to identify the following, and jot them down somewhere. Make note of the table name and the column name (we can also say "field" instead of column).

-   One or more columns / fields that has information in common, in that the data appears in both the ADI dataset and the CDC dataeset. Note that these data might not have the same field name in the two datasets. We'll call this our "join" data.
-   One or more columns / fields in the ADI data that help characterize socioeconomic disadvantage and are in the same table as the join data in the ADI version of the join data
-   One or more columns / fields in the CDC data that help describe something about birth statistics and are in the same table as our join data in the CDC version of the join data.

I'll start a timer for 5 minutes, and I want you to explore that data, get caught up on the slides, and take a break. 
:::


# SQL Refresher {.smaller}

This is the pattern we'll come back to again and again in SQL (Structured Query Language):

`SELECT + FROM + WHERE;`

| cabin | high_score | wins | losses |
|--|--|---|---|
| Yellow | 10 |3 |0|
|Blue |7 |2 |1 |
|Orange |9 |1| 2|

For example: `SELECT cabin, high_score FROM camp_kickball_tournament WHERE high_score < 10`


::: notes 

SQL, or Structured Query Language, is used to get information from a database that stores data in tables. Tables have rows, which are individual records, and columns, which are the values that are included in a record. 

We use a common pattern in SQL: SELECT plus some column names, FROM plus a table name, and WHERE plus some row conditions.

Consider, for example, this pretend table called camp_kickball_tournament.  If we wanted to extract just some data from this table, we could use the SELECT statement to indicate which columns, and the WHERE statement to indicate a filter to help determine which rows matched.  The FROM gives us the table name to look in.
:::

# Aliases (AS) 

Aliases allow you to (re)name things:

```
SELECT 
  cabin, 
  high_score, 
  wins/(wins + losses) AS prop_win   
FROM camp_kickball_tournament 
WHERE high_score < 10;
```

::: notes

You can use aliases to make things easier to read, by creating shortened names for things, renaming things that don't already have intuitive names, or calculating computed data and naming that data.

:::

# Whitespace / Capitalization {.smaller}

Which is easier to read?


::: {.columns .v-center-container}
::: {.column width="40%"}
```
SELECT 
  cabin, 
  high_score, 
  wins/(wins + losses) AS prop_win 
FROM camp_kickball_tournament 
WHERE high_score < 10;
```
:::
::: {.column width="60%"}

```
select cabin,high_score,wins/(wins + losses) as prop_win from camp_kickball_tournament where high_score < 10;
```
:::
:::

* Be consistent (reduce cognitive load on teammates / future you) 
* Capitalize key words so they stand out 
* Indent the parts of your query 
* Consider using a new line for every field

::: notes 
Both of these are valid SQL syntax and do the same thing, but one will make future-you happier.

Lots of digital ink has been spilled on the "right" way to structure SQL queries but it boils down to:

* Be consistent (reduce cognitive load on teammates / future you) 
* Capitalize key words so they stand out 
* Indent the parts of your query 
* Consider using a new line for every field

:::

# Query Button {.smaller}

Use the "Query" button (or the one with the magnifying glass) when you're looking within a table to avoid annoying syntax issues like having to type fully qualified table names (`project.dataset.table`).

![](media/query_button.png){.bordered .one-third}

::: notes
BigQuery requires fully qualified table names, where you include the project name, the dataset name, and the table name, all separated by periods and enclosed in backticks (not the same as single quotes).  This can be challenging to learn and hard to type correctly.

Skip the headache by starting with the "Query" button with the magnifying glass.  If you're zoomed in or there's not much screen real estate, this button might appear with only the magnifying glass.  This button is available when you're looking at the details of a particular table, and it will give you the start of a query with the table name included!

:::

# Queries in BigQuery  {.smaller}

Once you click "Query Table" (and then "New Tab" or whatever you prefer), you'll see a partial query, with the cursor located so that you can add fields after SELECT.

![](media/boilerplate_query.png){.bordered}

You'll also see warnings that your query is invalid.  That's expected!

::: notes
When you start a new query this way, you'll be given the start of a query with the table name included, and your cursor in the SELECT statement, where you could just type in a field name or two or three, separated by commas.

You'll also see red warnings that your query is invalid.  That's expected, because your query is in fact incomplete... you haven't indicated which fields you want in your SELECT statement.  You can hover over the error to get an explanation.
:::

# Your First Query {.smaller}

::: {.columns .v-center-container}
::: {.column width="60%"}
* You might have to adjust your pane widths to see all the buttons you need.
* Please click on the table in the CDC data (`sdoh_cdc_wonder_natality`) called `county_natality`. * Click on the "query" button and choose "In split tab".
* Add one or more fields from the schema of the table between the words "SELECT" and "FROM" in the query.
* When you get a green check mark showing that your query is valid, click the blue "Run" button above your query.
:::
::: {.column width="40%"}
![](media/first_query){.bordered}
:::
:::

```{r echo = FALSE}
library(countdown)
countdown(minutes = 3, seconds = 00)
```


::: notes
OK, so you're going to issue the first SQL query in the workshop today.  Note that you might have to adjust your pane widths to see all the buttons you need.

I'd like for you to look in your starred datasets, and  click on the table in the CDC data called `county_natality`.

Then, click on the query button, which will have a magnifying glass, and choose "split tab."  That will allow you to see the Schema and the Query on the same screen.

Using what you know from the Schema, add one or more field names that are valid for this table in the SQL query, right after the word SELECT.

When you get a green check mark showing that your query is valid, click the blue "Run" button above your query.

I'll give everyone 3 minutes for this.

Great, so now let me demonstrate this in case any of you had issues.

I'm going to go into the table I want, county natality, and click on the query button.  Notice that if my panes are too narrow, I might not see this button, and either need to click on the kebab menu, or broaden my pane.

I'll choose to write my query in a split tab, just because I like to see multiple things in a single screen.  You can also choose a new tab, and select which tab you want to be in by clicking on it.

My query is almost entirely built, but I have to add some field names.  I'll add a couple here, making sure I get capitalization, spelling, and punctuation of the column names exactly right.

Then my red exclamation points turn to green, and I can execute my query.  Again, if I don't see the "Run" button, I might need to broaden my pane or look in the kebab menu. 

My query results show up below my query, and I can work with them a number of different ways.  But before we get into that, I us to experiment a bit more with helpful tools in BigQuery.
:::


# Using Gemini to Learn SQL

Let's use the AI assistant to learn some SQL!

![](media/gemini_query.png){.bordered}

::: notes
0:25 

One of the benefits of Gemini is that it can help compose your SQL code if you're new.  Let's say we want to understand the categorical data in one of our tables.

The table in the CDC births data which is called "county natality by maternal morbidity" has some maternal morbidity descriptions, and I'd like to understand how many of those there are.  Is it a yes/no field?  Something like a diagnosis from ICD or Snomed or some other ontology?  Or is this a field that anyone could fill in with their own words, so there's no standardization, so maybe there are ten thousand different descriptions with no standardizations?

Now, I happen to know that I can use the SQL keyword DISTINCT to answer this question, but what if I didn't know?  Well, that's where we can use the Gemini AI assistant to help us.  See how there's a little Gemini star and pencil icon up in the corner of my boilerplate query?  Let's try this.  I'll screenshare now, and navigate away from my slides.

OK, so I'm going to start from my project dashboard, just get a fresh tab here and close what I was working on before.

Now that I'm in my dashboard, I'll choose BigQuery to open that up, make sure I'm looking at my starred data, to make the public datasets I care about appear.  And I want to expand the CDC data and select the maternal morbidities table.

In the schema, some of these fields make sense.  I can guess what's in them, like I expect average age of mother to be some sort of numeric field, probably a decimal, between, say, 15 and 45, but probably in the 20s or 30s.  But I am not quite sure how to make sense of Maternal_Morbidity_Desc.  It seems like this table doesn't contain individual level data, but county averages.  So what would go in a morbidity description?  Does this table have averages for each kind of morbidity, like gestational diabetes or hyperemesis?  I'm not sure. 

So I'll go over to the Preview, and I can look around, but scrolling through, I'm still not sure what I might see throughout the entire table.  It seems like we have lots and lots of rows with the same value: None Checked.  But what if a morbidity was checked?  What would that look like?  How many are there?  I'd like to write a query so that the information I get back is quantitative and my method for getting that information is reproducible, and not just "well I scrolled through and visually I think this is what the table contains."

So I'm going to click on the Query button with the magnifying glass and open a query in a new tab.  As a reminder, this gives me a template for a query in this table, so I don't have to write out the table name.  Since I don't know where to start, I'm going to click on the Gemini icon here and ask a question: "What are the possible values for maternal morbidity description?"  Note that I don't even give the formal name of the field, I kind of say it in English.  Let's see what Gemini will make of that.

OK, wow, it does an okay job, this query seems to make sense. Now, I can "insert" it, but it's going to insert the whole query wherever my cursor is, which will be annoying.  So I'm going to copy it to my clipboard instead, and then paste it.

Does it work?  Uhhhh, it has a red alert... let's see what this is.  

OK, this shows one of the flaws of Gemini.  While this would be valid in other SQL dialects, it actually won't work in BigQuery SQL.

The thinking here is that in the SELECT statement, Gemini suggested that I refer to the column or field I want information about by table name dot field name notation, which is totally fine.  BUT, as we talked about earlier, to refer to a specific table in BigQuery I need more than just the table name.  I have to add the entire table name, fully qualified, using the project name and dataset name too.

So I have two options.

In this case, there's no ambiguity about what table this field belongs to, because I'm only asking SQL to look at this one single table.  So I could just delete the table name and use the field name.  Let's see if that will make this turn from red to green.  Oh it does!  And let's run it.

Three unique values.

The other option I have is to include the full table name, by copy/pasting it from this line below.  Now, this might seem redundant.  It's like saying "bring me the frying pan from my kitchen at my street address, and look in my kitchen at my street address."  It's silly!  But sometimes, and you'll do this in a bit, you might be querying from two tables, and both tables might have a column or field that share a name.  So if I want to refer to the date column, and date appears in both the births and deaths table, which one do I mean?  The date column in births, or the date column in deaths?  

So let's try this version of the query.  It works, and we get the same info.

Now I'd like to give you a couple of minutes to look at the links that appear at the bottom of an AI-generated query.  I'm going to put in a new question, and have you do the same thing. Either the same question as me or a different one. Once you see the query appear, and then at the bottom I can see three things that I want you to click on and investigate.  Edit Table Sources, Query Summary, and Use query with caution.  I'll give you 5 minutes to take a quick look at these.

:::


# JOINs in SQL

I asked you before to find three things, and now we'll use them in a JOIN in SQL. 

-   One or more fields that has linking information in common, in that the data appears in both datasets 
-   One or more columns / fields in the ADI data that help characterize socioeconomic disadvantage and are in the same table as our join data
-   One or more columns / fields in the CDC data that help describe something about birth statistics and are in the same table as our join data

::: notes

I asked you before to find three things: 

-   One or more fields that has linking information in common, in that the data appears in both datasets (might not have the same field name) -- we'll call this our "join" data
-   One or more columns / fields in the ADI data that help characterize socioeconomic disadvantage and are in the same table as our join data
-   One or more columns / fields in the CDC data that help describe something about birth statistics and are in the same table as our join data

You might be accustomed to joining or merging data from two dataframes in R, and you know how to do that, so why am I going to teach you how to JOIN in SQL?  

Well, sometimes you're working with very large data in BigQuery, and you might want to make the data you bring into R smaller and more compact.  Instead of bringing over two huge, million row tables into R and doing a merge or join there, it can be more efficient to do that kind of first step in SQL.

In fact, I like to describe SQL as a heavy-duty tool.  If you imagine creating a sculpture out of wood or marble, you might envision -- and I'm not a sculptor, so forgive me if I'm wrong about this -- you might envision the first pass of your sculpture as getting rid of what you know you won't use with a very powerful and blunt instrument.  We're talking using a chainsaw or jackhammer.  Could you carve a spoon out of the heartwood of a tree trunk, using a fine set of chisels?  You could, but it's not quite the right tool for the job.  SQL is very powerful and fast and will do data joining much more efficiently than R.  BigQuery especially is well built to do this at scale.  So I'm going to use SQL to rough out my dataset, then bring it into R for finer detail work.  

:::

# Joins -- things to consider {.smaller}

::: {.columns .v-center-container}
::: {.column width="33%"}
What to join?

* What two tables give us a fuller picture of our data, when used together?
* What fields from each table will we include?

:::
::: {.column width="33%"}
What constitutes a join?

* What needs to happen for rows to be a "match"?
* Which linking field(s) are involved?
:::
::: {.column width="33%"}
Which type of join / data completion

* Which part of the Venn Diagram of table overlap do we care about?  Things that show up in only one table?  Or in both?
:::
:::

::: notes

:::

# Join Types {.smaller}

There are 4 basic join types that can be used. We'll go into more detail about how each one works in the next few pages.

Here, we simply provide a visual highlight to indicate the part of the data that's considered for inclusion with each type of join.


::: {.columns .v-center-container}
::: {.column width="25%"}
`INNER JOIN` (or just `JOIN`)
![](media/inner_join.png)
:::
::: {.column width="25%"}
`LEFT` (or `LEFT OUTER`) JOIN
![](media/left_outer_join.png)

:::
::: {.column width="25%"}
`RIGHT` (or `RIGHT OUTER`) JOIN
![](media/right_outer_join.png)



:::
::: {.column width="25%"}
`FULL` (or `FULL OUTER`) JOIN
![](media/full_outer_join.png)

:::
:::

::: notes

:::

INNER JOIN


# Our example: ADI and Birth Characteristics  {.smaller}

* What data do we want?  Information about socioeconomic disadvantage (ADI tables) and how that relates to birth characteristics (CDC tables)
* What will link the data from the two sources?  The county has to match (either the name or the FIPS code or both)
* What kind of data completion do we want?  Only data where we have both ADI data and CDC data about the county.

::: notes
So in this example, we have county-level data about ADI, which is a socioeconomic score, and county-level data about birth characteristics.  Let's say we want to join these datasets together.

What linking data do we have?  We have information about the county.  I asked you to identify particular fields that might be able to link data from these two datasets.  What would you propose?  Let's consider the alternatives.

And if we wanted to take a pertinent county-level measure of ADI, what would you choose?  What about CDC?
:::

# Syntax of a JOIN  {.smaller}

The basic syntax of a join is:

```
SELECT [fields we want]
FROM [left table name] [some join type] [right table name]
ON (or USING) [join criteria]

```

::: notes
On your screen, you see the syntax of a JOIN.  Let's do one, using the fields we came up with.  Now, I wasn't sure what you all would choose, but I went ahead and did some slides with what I think might be useful. Let's see what I assembled!

:::

# A Sample JOIN  {.smaller}

![](media/join_sample.png){.bordered}

::: notes
OK, let's start from the bottom and work our way up.  In lines 7 and 8 I have the two tables I want to join.  I've chosen to put the area_deprivation_index_by_county table from the ADI first, or on the left, and the county_natality table from the CDC second, or on the right. Now, what kind of join do I want? That determines what words appear between these two tables.  In my case, I'm not interested in data from the left side, the Births data side, unless the counties there also appear on the right side, the ADI side.  I'm interested in the full overlap.

Those two tables have something in common, and that's what I've put in line 9: the county fips code, which goes by a different name in each table, must match.  

Now, what kind of join do I want?  
:::

# Aggregation  {.smaller}

Aggregation gives you a single calculated value for multiple rows.  Examples include:

* COUNT 
* MIN / MAX
* SUM

# Aggregation Examples  {.smaller}

A Few Aggregate Functions: 

* ANY_VALUE (give me any one of the values)
* AVG (mean of values)
* CORR (Pearson's coefficient of correlation between 2 sets of values)
* COUNT (number of rows)
* COUNTIF (number of rows that match your description)
* MAX (maximum from a set of values)
* MIN (minimum from a set of values)
* STDDEV (shortcut for STDDEV_POP, gives sample standard deviation for set of values)
8 SUM (sum of values)

# Let's do some aggregation



